<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate and Evaluate Python Code with LLaMA 4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center my-8">Generate and Evaluate Python Code</h1>
        <p class="text-center mb-2 text-gray-600">Powered by Groq inference and Daytona sandboxes</p>
        <p class="text-center mb-8 text-gray-500 text-xs italic" id="modelInfo">Using model: <span id="modelName" class="font-mono">{{ model_name }}</span></p>

        <div id="testModeBanner" class="hidden max-w-2xl mx-auto mb-4 bg-yellow-100 border-l-4 border-yellow-500 p-4">
            <div class="flex">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                    </svg>
                </div>
                <div class="ml-3">
                    <p class="text-sm text-yellow-700">
                        Running in test mode with simulated outputs. API keys not configured.
                    </p>
                </div>
            </div>
        </div>

        <div class="max-w-2xl mx-auto bg-white rounded-lg shadow-md p-6">
            <form id="codeForm" class="space-y-4" action="/execute">
                <div class="flex flex-wrap items-center justify-between mb-1">
                    <label for="user_input" class="text-sm font-medium text-gray-700">
                        Describe what Python code you want to generate:
                    </label>
                    <div class="flex items-center">
                        <label for="sandbox_count" class="text-sm font-medium text-gray-700 mr-2">
                            Sandboxes:
                        </label>
                        <input
                            type="number"
                            id="sandbox_count"
                            name="sandbox_count"
                            min="1"
                            value="3"
                            class="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        />
                    </div>
                </div>
                <div>
                    <textarea
                        id="user_input"
                        name="user_input"
                        rows="4"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                        placeholder="e.g., Create a function that sorts a list of dictionaries by a specific key"
                        required
                    ></textarea>
                </div>
                <div>
                    <button
                        type="submit"
                        id="submitButton"
                        class="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                    >
                        Generate and Execute Code
                    </button>
                </div>
            </form>

            <div id="loadingIndicator" class="hidden mt-6 text-center">
                <div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-600"></div>
                <p class="mt-2 text-gray-600">Processing your request in sandboxes...</p>
                <p class="mt-1 text-sm text-gray-500">This may take 1-2 minutes</p>
            </div>

            <div id="sandboxVisualization" class="mt-6">
                <h3 class="text-lg font-medium mb-2">Sandbox Status</h3>
                <div id="visualizationContainer" class="h-64 bg-gray-50 rounded-lg p-4 relative">
                    <!-- D3 visualization will be rendered here -->
                </div>
                <div class="flex flex-wrap gap-3 mt-2 text-xs justify-center">
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-gray-200 border border-gray-500 mr-1"></div>
                        <span>Pending</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-blue-100 border border-blue-500 mr-1"></div>
                        <span>Creating</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-yellow-100 border border-yellow-500 mr-1"></div>
                        <span>Preparing</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-green-100 border border-green-500 mr-1"></div>
                        <span>Ready</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-purple-100 border border-purple-500 mr-1"></div>
                        <span>Generating</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-indigo-100 border border-indigo-500 mr-1"></div>
                        <span>Executing</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-green-500 border border-green-700 mr-1" id="complete-legend"></div>
                        <span>Complete</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-red-500 border border-red-700 mr-1" id="error-legend"></div>
                        <span>Error</span>
                    </div>
                </div>
                
                <!-- Add styles to ensure consistent coloring -->
                <style>
                    /* Status-specific colors */
                    .status-complete {
                        fill: #10b981 !important;
                        stroke: #047857 !important;
                    }
                    
                    .status-error {
                        fill: #ef4444 !important;
                        stroke: #b91c1c !important;
                    }
                    
                    #complete-legend {
                        background-color: #10b981;
                        border-color: #047857;
                    }
                    
                    #error-legend {
                        background-color: #ef4444;
                        border-color: #b91c1c;
                    }
                </style>
            </div>

            <div id="errorContainer" class="hidden mt-6 p-4 bg-red-50 border border-red-300 rounded-lg shadow-sm">
                <div class="flex items-start">
                    <div class="flex-shrink-0">
                        <!-- Error icon -->
                        <svg class="h-5 w-5 text-red-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <h3 class="text-lg font-medium text-red-800">Error</h3>
                        <div id="errorMessage" class="mt-2 text-sm text-red-700"></div>
                        
                        <!-- Connection error help text -->
                        <div id="connectionErrorHelp" class="mt-3 p-3 bg-white rounded border border-red-200 text-sm hidden">
                            <p class="font-medium mb-2">Troubleshooting Steps:</p>
                            <ul class="list-disc list-inside space-y-1 text-gray-700">
                                <li>Check that the Flask server is running in your terminal</li>
                                <li>Make sure you're using the correct URL (usually http://localhost:5000)</li>
                                <li>Verify that no firewall is blocking the connection</li>
                                <li>Try restarting the server with <code class="bg-gray-100 px-1 py-0.5 rounded">python app.py</code></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div id="results" class="hidden mt-6">
                <!-- Implementation results -->
                <div class="space-y-6" id="implementationsContainer">
                    <!-- Implementation results will be added here dynamically -->
                </div>
                
                <!-- Overall Results (moved below implementations) -->
                <div class="mt-10 mb-6 bg-white rounded-lg shadow-lg p-6 border border-gray-200">
                    <h2 class="text-xl font-semibold mb-4">Result Summary</h2>
                    
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-2">Best Agent Solution</h3>
                        <div id="evaluationResult" class="bg-gray-50 p-4 rounded-md text-sm"></div>
    
                        <div id="bestOutputPreview" class="mt-4" style="display: none;">
                            <h4 class="font-medium text-sm mb-2">Output Preview:</h4>
                            <pre id="bestOutputContent" class="bg-gray-50 p-3 rounded text-sm overflow-x-auto border border-green-200"></pre>
                        </div>
                    </div>
                    
                    <!-- Overall Performance Metrics -->
                    <div id="overallTimingInfo" class="p-4 bg-blue-50 rounded-lg">
                        <h3 class="text-lg font-semibold mb-2">Performance Summary</h3>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div class="bg-white p-3 rounded shadow-sm">
                                <div class="text-sm text-gray-500">Total Time</div>
                                <div id="totalExecutionTime" class="text-xl font-semibold">-</div>
                            </div>
                            <div class="bg-white p-3 rounded shadow-sm">
                                <div class="text-sm text-gray-500">Avg Sandbox Creation</div>
                                <div id="avgSandboxCreation" class="text-xl font-semibold">-</div>
                            </div>
                            <div class="bg-white p-3 rounded shadow-sm">
                                <div class="text-sm text-gray-500">Avg Code Generation</div>
                                <div id="avgGroqTime" class="text-xl font-semibold">-</div>
                            </div>
                            <div class="bg-white p-3 rounded shadow-sm">
                                <div class="text-sm text-gray-500">Sandboxes Created</div>
                                <div id="sandboxCount" class="text-xl font-semibold">-</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize socket connection
        let socket;
        let currentSessionId = null;
        let sandboxNodes = [];
        let simulation;
        let visualizationInitialized = false;

        try {
            socket = io();
            console.log("SocketIO connection established");
        } catch (e) {
            console.error("Failed to connect to SocketIO:", e);
        }

        // Socket event handlers
        if (socket) {
            socket.on('connect', function() {
                console.log('Connected to server');
            });

            socket.on('sandbox_status', function(data) {
                console.log('Received sandbox status update:', data);

                // If this is a new session, update the session ID
                if (currentSessionId !== data.session_id) {
                    currentSessionId = data.session_id;
                    console.log("New session ID:", currentSessionId);

                    // Ensure visualization is shown for a new session
                    document.getElementById('sandboxVisualization').classList.remove('hidden');
                }

                // Extra debugging for completed and error states
                if (data.status === 'complete' || data.status === 'error') {
                    console.log(`⚠️ IMPORTANT: Sandbox ${data.sandbox_id} is now ${data.status.toUpperCase()} with progress ${data.progress}`);
                }

                // Update visualization and log status change
                console.log(`Updating sandbox ${data.sandbox_id} to status: ${data.status} with progress: ${data.progress}`);
                updateSandboxStatus(data.sandbox_id, data.status, data.progress);
            });
        }

        // Helper function to get status colors
        function getStatusFillColor(status) {
            switch(status) {
                case 'pending': return "#e5e7eb";
                case 'creating': return "#dbeafe";
                case 'preparing': return "#fef3c7";
                case 'ready': return "#bbf7d0";
                case 'generating': return "#f3e8ff";
                case 'executing': return "#e0e7ff";
                case 'complete': return "#10b981";
                case 'error': return "#ef4444";
                default: return "#e5e7eb";
            }
        }
        
        function getStatusStrokeColor(status) {
            switch(status) {
                case 'pending': return "#6b7280";
                case 'creating': return "#3b82f6";
                case 'preparing': return "#d97706";
                case 'ready': return "#22c55e";
                case 'generating': return "#a855f7";
                case 'executing': return "#6366f1";
                case 'complete': return "#047857";
                case 'error': return "#b91c1c";
                default: return "#6366f1";
            }
        }
            
        // Initialize the visualization
        function initVisualization(sandboxCount) {
            console.log("Initializing visualization with", sandboxCount, "sandboxes");
            
            // Clean up any existing simulation
            if (simulation) {
                simulation.stop();
            }
            
            // Clean up any lingering intervals from previous runs
            if (sandboxNodes && sandboxNodes.length) {
                sandboxNodes.forEach(node => {
                    if (node.pulseInterval) {
                        clearInterval(node.pulseInterval);
                        node.pulseInterval = null;
                    }
                });
            }

            // Clear previous visualization completely
            d3.select("#visualizationContainer").selectAll("*").remove();
            
            // Remove any custom style tags added for node colors
            document.querySelectorAll('style[data-purpose="node-color"]').forEach(el => el.remove());
            
            // Get container dimensions
            const container = document.getElementById('visualizationContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Mark visualization as initialized
            visualizationInitialized = true;
            
            // Reset sandbox nodes completely
            sandboxNodes = [];

            // Create SVG container
            const svg = d3.select("#visualizationContainer")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Initialize nodes for each sandbox
            sandboxNodes = Array.from({length: sandboxCount}, (_, i) => ({
                id: i,
                status: 'pending',
                progress: 0,
                x: Math.random() * width * 0.7 + width * 0.15,
                y: Math.random() * height * 0.7 + height * 0.15,
                r: 25
            }));

            // Create a central node
            const centerNode = {
                id: 'center',
                x: width / 2,
                y: height / 2,
                fixed: true,
                r: 15,
                status: 'main'
            };

            // Create links from center to each sandbox
            const links = sandboxNodes.map(node => ({
                source: centerNode,
                target: node
            }));

            // Add center node to the nodes array
            const allNodes = [centerNode, ...sandboxNodes];

            // Create force simulation
            simulation = d3.forceSimulation(allNodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(d => (d.r || 25) + 10))
                .on("tick", ticked);

            // Add links
            const link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter()
                .append("line")
                .attr("stroke", "#d1d5db")
                .attr("stroke-width", 1.5)
                .attr("stroke-dasharray", "4,4");

            // Add nodes
            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll(".node")
                .data(allNodes)
                .enter()
                .append("g")
                .attr("class", d => `node node-${d.id}`)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // Add circles for each node
            node.append("circle")
                .attr("r", d => d.r || 25)
                .attr("fill", d => {
                    if (d.id === 'center') return "#4f46e5";
                    return getStatusFillColor(d.status || 'pending');
                })
                .attr("stroke", d => {
                    if (d.id === 'center') return "#ffffff";
                    return getStatusStrokeColor(d.status || 'pending');
                })
                .attr("stroke-width", 2)
                .attr("class", d => `node-circle node-circle-${d.id}`);

            // Add labels
            node.append("text")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "central")
                .attr("fill", d => d.id === 'center' ? "#ffffff" : "#374151")
                .attr("font-size", d => d.id === 'center' ? "10px" : "12px")
                .attr("font-weight", "bold")
                .text(d => d.id === 'center' ? "Main" : `#${d.id+1}`);

            // Add progress arcs
            node.filter(d => d.id !== 'center')
                .append("path")
                .attr("class", d => `progress-arc progress-arc-${d.id}`)
                .attr("fill", "none")
                .attr("stroke", "#6366f1")
                .attr("stroke-width", 3)
                .attr("stroke-linecap", "round");

            // Add tooltips
            node.append("title")
                .text(d => d.id === 'center' ? "Main Coordinator" : `Sandbox #${d.id+1}\nStatus: ${d.status}\nProgress: ${d.progress}%`);

            // Animation on creation
            node.attr("opacity", 0)
                .transition()
                .duration(500)
                .delay((d, i) => i * 100)
                .attr("opacity", 1);

            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);

                // Update progress arcs
                updateProgressArcs();
            }

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                if (d.id !== 'center') {
                    d.fx = null;
                    d.fy = null;
                }
            }

            // Initial update of progress arcs
            updateProgressArcs();
        }

        // Update sandbox status in visualization
        function updateSandboxStatus(sandboxId, status, progress) {
            console.log(`Updating sandbox ${sandboxId} status: ${status}, progress: ${progress}`);

            // Make sure the visualization is initialized
            if (!visualizationInitialized) {
                console.log("Visualization not initialized yet, initializing now");
                const sandboxCount = parseInt(document.getElementById('sandbox_count').value) || 3;
                initVisualization(sandboxCount);
                document.getElementById('sandboxVisualization').classList.remove('hidden');
            }

            // Find the node
            const node = sandboxNodes.find(n => n.id === sandboxId);
            if (!node) {
                console.warn(`No node found for sandbox ID ${sandboxId}`);
                return;
            }

            // Update node data
            node.status = status;
            node.progress = progress;

            // Special handling for complete and error states
            if (status === 'complete' || status === 'error') {
                // Get the circle element
                const circle = d3.select(`.node-circle-${sandboxId}`);
                
                // Add color-related CSS class for consistent styling
                document.querySelectorAll(`.node-circle-${sandboxId}`).forEach(el => {
                    // First, remove any existing status classes
                    el.classList.remove('status-pending', 'status-creating', 'status-preparing', 
                                       'status-ready', 'status-generating', 'status-executing',
                                       'status-complete', 'status-error');
                    
                    // Add the appropriate class
                    el.classList.add(`status-${status}`);
                    
                    // Directly apply color as inline style (highest priority)
                    if (status === 'complete') {
                        el.style.fill = "#10b981";
                        el.style.stroke = "#047857";
                        console.log(`🟢 Direct CSS green coloring for sandbox ${sandboxId} (complete)`);
                    } else if (status === 'error') {
                        el.style.fill = "#ef4444";
                        el.style.stroke = "#b91c1c";
                        console.log(`🔴 Direct CSS red coloring for sandbox ${sandboxId} (error)`);
                    }
                });
                
                // Backup D3 selection method
                if (status === 'complete') {
                    // Force green colors
                    circle.style("fill", "#10b981")
                          .style("stroke", "#047857");
                    console.log(`🟢 D3 green coloring for sandbox ${sandboxId} (complete)`);
                } else {
                    // Force red colors
                    circle.style("fill", "#ef4444")
                          .style("stroke", "#b91c1c");
                    console.log(`🔴 D3 red coloring for sandbox ${sandboxId} (error)`);
                }
            }

            // Update node appearance
            updateNodeAppearance(sandboxId);

            // Update progress arcs
            updateProgressArcs();

            // Update tooltip
            d3.select(`.node-${sandboxId} title`)
                .text(`Sandbox #${sandboxId+1}\nStatus: ${status}\nProgress: ${progress}%`);
        }

        // Update the appearance of a node based on its status
        function updateNodeAppearance(sandboxId) {
            const node = sandboxNodes.find(n => n.id === sandboxId);
            if (!node) return;

            console.log(`Updating appearance for sandbox ${sandboxId}, status: ${node.status}`);

            // Select the node circle
            const circle = d3.select(`.node-circle-${sandboxId}`);
            if (!circle.node()) {
                console.error(`Could not find circle element for sandbox ${sandboxId}`);
                return;
            }

            // Get the appropriate colors using our helper functions
            const fillColor = getStatusFillColor(node.status);
            const strokeColor = getStatusStrokeColor(node.status);
            
            if (node.status === 'complete' || node.status === 'error') {
                console.log(`Setting ${node.status} colors for sandbox ${sandboxId}: fill=${fillColor}, stroke=${strokeColor}`);
            }
            
            console.log(`Final colors for sandbox ${sandboxId}: fill=${fillColor}, stroke=${strokeColor}`);

            // Update colors with transition
            circle.transition()
                .duration(300)
                .attr("fill", fillColor)
                .attr("stroke", strokeColor);

            // Add pulse effect on status change
            circle.transition()
                .duration(300)
                .attr("r", 30)
                .transition()
                .duration(300)
                .attr("r", 25);
                
            // Add continuous pulsing animation for complete and error states
            if (node.status === 'complete' || node.status === 'error') {
                console.log(`Setting up pulsing animation for ${node.status} sandbox ${sandboxId}`);
                
                // Debug the node and color values
                console.log(`DEBUG - Node status: ${node.status}`);
                console.log(`DEBUG - Expected fill color: ${getStatusFillColor(node.status)}`);
                console.log(`DEBUG - Expected stroke color: ${getStatusStrokeColor(node.status)}`);
                
                // Create a hacky function to modify the SVG directly
                window.d3NodeFixer = window.d3NodeFixer || {};
                window.d3NodeFixer[sandboxId] = {
                    status: node.status,
                    selector: `.node-circle-${node.id}`
                };
                
                // Ultra-aggressive approach:
                // 1. Create an inline script that directly modifies the SVG element
                const styleScript = document.createElement('script');
                styleScript.dataset.purpose = "node-color";
                styleScript.dataset.nodeId = node.id;
                styleScript.textContent = `
                    // This script directly modifies the SVG element
                    (function() {
                        const svgEl = document.querySelector('.node-circle-${node.id}');
                        if (svgEl) {
                            svgEl.setAttribute('style', 'fill: ${node.status === 'complete' ? '#10b981' : '#ef4444'} !important; stroke: ${node.status === 'complete' ? '#047857' : '#b91c1c'} !important;');
                            svgEl.setAttribute('fill', '${node.status === 'complete' ? '#10b981' : '#ef4444'}');
                            svgEl.setAttribute('stroke', '${node.status === 'complete' ? '#047857' : '#b91c1c'}');
                            console.log('[Inline Script] Applied ${node.status} colors to .node-circle-${node.id}');
                        } else {
                            console.log('[Inline Script] Could not find .node-circle-${node.id}');
                        }
                    })();
                `;
                document.head.appendChild(styleScript);
                
                // Force the colors directly (bypassing any transition issues)
                if (node.status === 'complete') {
                    // Directly force green colors for completed nodes
                    circle.style("fill", "#10b981")
                          .style("stroke", "#047857")
                          .attr("fill", "#10b981") 
                          .attr("stroke", "#047857");
                    
                    console.log("DEBUG - Forcing GREEN colors for completed node");
                } else if (node.status === 'error') {
                    // Directly force red colors for error nodes
                    circle.style("fill", "#ef4444")
                          .style("stroke", "#b91c1c")
                          .attr("fill", "#ef4444")
                          .attr("stroke", "#b91c1c");
                    
                    console.log("DEBUG - Forcing RED colors for error node");
                }
                
                // Also inject a style tag to force colors via CSS
                const styleTag = document.createElement('style');
                styleTag.dataset.purpose = "node-color";
                styleTag.dataset.nodeId = node.id;
                styleTag.textContent = `
                    .node-circle-${node.id} {
                        fill: ${node.status === 'complete' ? '#10b981' : '#ef4444'} !important;
                        stroke: ${node.status === 'complete' ? '#047857' : '#b91c1c'} !important;
                    }
                `;
                document.head.appendChild(styleTag);
                
                // Clear any existing interval to avoid multiple animations
                if (node.pulseInterval) clearInterval(node.pulseInterval);
                
                // Setup pulsing animation that also reapplies colors
                node.pulseInterval = setInterval(() => {
                    const nodeEl = d3.select(`.node-circle-${node.id}`);
                    // First apply correct colors
                    if (node.status === 'complete') {
                        nodeEl.style("fill", "#10b981")
                              .style("stroke", "#047857")
                              .attr("fill", "#10b981")
                              .attr("stroke", "#047857");
                    } else {
                        nodeEl.style("fill", "#ef4444")
                              .style("stroke", "#b91c1c")
                              .attr("fill", "#ef4444")
                              .attr("stroke", "#b91c1c");
                    }
                    
                    // Then do the pulse animation
                    nodeEl.transition()
                        .duration(800)
                        .attr("r", 28)
                        .transition()
                        .duration(800)
                        .attr("r", 25);
                }, 1600);
            }
        }

        // Update progress arcs for all nodes
        function updateProgressArcs() {
            sandboxNodes.forEach(node => {
                if (node.progress > 0) {
                    const arcGenerator = d3.arc()
                        .innerRadius(23)
                        .outerRadius(27)
                        .startAngle(0)
                        .endAngle(node.progress * Math.PI * 2 / 100);

                    d3.select(`.progress-arc-${node.id}`)
                        .attr("d", arcGenerator());
                }
            });
        }

        // Check if in test mode by looking for the URL parameter
        if (window.location.href.includes('/test')) {
            document.getElementById('testModeBanner').classList.remove('hidden');
        }

        // Function to reset all D3 node colors to initial state
        function resetNodeColors() {
            console.log("🧹 Resetting all node colors to initial state");
            
            // Remove all color-specific style tags and scripts
            document.querySelectorAll('style[data-purpose="node-color"], script[data-purpose="node-color"]')
                .forEach(el => el.remove());
            
            // Reset window.d3NodeFixer
            window.d3NodeFixer = {};
            
            // Apply pending color to all nodes
            d3.selectAll(".node-circle").each(function(d) {
                // Skip center node
                if (d.id === 'center') return;
                
                // Reset to default pending color
                d3.select(this)
                    .style("fill", "#e5e7eb")
                    .style("stroke", "#6b7280")
                    .attr("fill", "#e5e7eb")
                    .attr("stroke", "#6b7280")
                    .classed("status-complete", false)
                    .classed("status-error", false)
                    .classed("status-pending", true);
            });
        }
        
        // Function to directly fix node colors - can be called at any time
        function fixNodeColors() {
            console.log("🔧 Fixing node colors for all sandboxes");
            
            // Loop through all sandbox nodes
            sandboxNodes.forEach(node => {
                if (node.status === 'complete' || node.status === 'error') {
                    const nodeId = node.id;
                    const selector = `.node-circle-${nodeId}`;
                    
                    // Get the SVG element
                    const svgEl = document.querySelector(selector);
                    const color = node.status === 'complete' ? 
                                  {fill: '#10b981', stroke: '#047857'} : 
                                  {fill: '#ef4444', stroke: '#b91c1c'};
                    
                    console.log(`🎨 Setting ${node.status} colors for node ${nodeId}: ${color.fill}/${color.stroke}`);
                    
                    // Apply colors using DOM API
                    if (svgEl) {
                        svgEl.setAttribute('fill', color.fill);
                        svgEl.setAttribute('stroke', color.stroke);
                        svgEl.style.fill = color.fill;
                        svgEl.style.stroke = color.stroke;
                    }
                    
                    // Also apply with D3 for good measure
                    d3.select(selector)
                      .style("fill", color.fill)
                      .style("stroke", color.stroke)
                      .attr("fill", color.fill)
                      .attr("stroke", color.stroke);
                }
            });
        }
        
        // We'll also patch socket listener to call our fix colors function
        const originalSocketHandler = socket.on;
        socket.on = function(event, handler) {
            if (event === 'sandbox_status') {
                const wrappedHandler = function(data) {
                    // Call the original handler
                    handler(data);
                    
                    // If this is a complete or error status, fix colors
                    if (data.status === 'complete' || data.status === 'error') {
                        console.log(`💫 Status event for node ${data.sandbox_id}: ${data.status} - calling fixNodeColors`);
                        setTimeout(fixNodeColors, 100);  // Small delay to ensure everything is updated
                    }
                };
                return originalSocketHandler.call(this, event, wrappedHandler);
            }
            return originalSocketHandler.call(this, event, handler);
        };
        
        document.getElementById('codeForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const userInput = document.getElementById('user_input').value;
            const sandboxCount = parseInt(document.getElementById('sandbox_count').value);
            const submitButton = document.getElementById('submitButton');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const resultsContainer = document.getElementById('results');
            const errorContainer = document.getElementById('errorContainer');
            const errorMessage = document.getElementById('errorMessage');
            const evaluationResult = document.getElementById('evaluationResult');
            const implementationsContainer = document.getElementById('implementationsContainer');

            // Reset visualization and clean up intervals
            sandboxNodes.forEach(node => {
                if (node.pulseInterval) {
                    clearInterval(node.pulseInterval);
                    node.pulseInterval = null;
                }
                
                // Clean up any DOM styles that might have been added for this node
                document.querySelectorAll(`style[data-purpose="node-color"][data-node-id="${node.id}"]`)
                    .forEach(el => el.remove());
                document.querySelectorAll(`script[data-purpose="node-color"][data-node-id="${node.id}"]`)
                    .forEach(el => el.remove());
            });
            
            // Reset global state
            sandboxNodes = [];
            currentSessionId = null;
            
            // Reset all node colors explicitly
            resetNodeColors();
            
            // Remove D3 window global helpers
            window.d3NodeFixer = {};

            // Initialize visualization immediately with the current sandbox count
            initVisualization(sandboxCount);

            // Show visualization and loading indicator
            document.getElementById('sandboxVisualization').classList.remove('hidden');
            loadingIndicator.classList.remove('hidden');
            resultsContainer.classList.add('hidden');
            errorContainer.classList.add('hidden');
            submitButton.disabled = true;
            submitButton.classList.add('opacity-50');

            try {
                // Get the form action (which might be /test in test mode)
                const formAction = this.getAttribute('action') || '/execute';
                console.log('Using endpoint:', formAction);

                const response = await fetch(formAction, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        user_input: userInput,
                        sandbox_count: document.getElementById('sandbox_count').value
                    })
                }).catch(error => {
                    // Custom handling for network errors (server not running)
                    throw new Error("Connection failed. Please check if the server is running and try again.");
                });

                const data = await response.json();

                if (data.error) {
                    // Show error message
                    errorMessage.textContent = data.error;
                    errorContainer.classList.remove('hidden');
                    loadingIndicator.classList.add('hidden');
                    submitButton.disabled = false;
                    submitButton.classList.remove('opacity-50');
                    return;
                }

                // Display evaluation result
                let evaluationText = data.evaluation && data.evaluation.evaluation
                    ? data.evaluation.evaluation
                    : 'No evaluation available';

                // Replace "implementation" with "agent" in the evaluation text
                evaluationText = evaluationText.replace(/implementation (\d+)/gi, 'Agent $1');
                
                evaluationResult.textContent = evaluationText;

                // Show best agent output preview if available
                const bestOutputPreview = document.getElementById('bestOutputPreview');
                const bestOutputContent = document.getElementById('bestOutputContent');

                if (data.evaluation && data.evaluation.best_implementation) {
                    const bestOutput = data.evaluation.best_implementation.execution_output;
                    if (bestOutput && bestOutput.trim()) {
                        bestOutputContent.textContent = bestOutput;
                        bestOutputPreview.style.display = 'block';
                    } else {
                        bestOutputPreview.style.display = 'none';
                    }
                } else {
                    bestOutputPreview.style.display = 'none';
                }

                // Calculate and display performance metrics
                if (data.results && data.results.length > 0 && data.timing_data) {
                    // Format time function (ms for < 1s, s for >= 1s)
                    const formatTime = (seconds) => {
                        if (seconds < 1) {
                            return Math.round(seconds * 1000) + 'ms';
                        } else {
                            return seconds.toFixed(2) + 's';
                        }
                    };

                    // Display total execution time
                    document.getElementById('totalExecutionTime').textContent =
                        formatTime(data.timing_data.total_execution_time || 0);

                    // Calculate average sandbox creation time
                    const creationTimes = data.results.map(r => r.sandbox_creation_time || 0);
                    const avgCreationTime = creationTimes.reduce((a, b) => a + b, 0) / creationTimes.length;
                    document.getElementById('avgSandboxCreation').textContent = formatTime(avgCreationTime);

                    // Calculate average GROQ API time
                    const groqTimes = data.results.map(r => r.groq_time || 0);
                    const avgGroqTime = groqTimes.reduce((a, b) => a + b, 0) / groqTimes.length;
                    document.getElementById('avgGroqTime').textContent = formatTime(avgGroqTime);

                    // Display sandbox count
                    document.getElementById('sandboxCount').textContent = data.results.length;
                }

                // Clear previous agent results
                implementationsContainer.innerHTML = '';

                // Add agent results
                if (Array.isArray(data.results)) {
                    data.results.forEach((result, index) => {
                        const implementationDiv = document.createElement('div');
                        implementationDiv.className = 'border rounded-md overflow-hidden';

                        const header = document.createElement('div');
                        // Highlight the best implementation if it matches the evaluation result
                        const isBestImpl = data.evaluation &&
                            data.evaluation.best_implementation_index === (index + 1);
                        
                        // Check if implementation succeeded or failed
                        const isSuccess = result.execution_result === 'Success';
                        
                        // Determine header color based on status
                        let headerClass = 'px-4 py-2 font-semibold flex items-center justify-between';
                        if (isBestImpl) {
                            headerClass = 'bg-green-200 ' + headerClass;
                        } else if (!isSuccess) {
                            headerClass = 'bg-red-200 ' + headerClass;
                        } else {
                            headerClass = 'bg-gray-200 ' + headerClass;
                        }
                        
                        header.className = headerClass;

                        const titleSpan = document.createElement('span');
                        titleSpan.textContent = `Agent ${index + 1}`;
                        header.appendChild(titleSpan);

                        if (isBestImpl) {
                            const badgeSpan = document.createElement('span');
                            badgeSpan.className = 'bg-green-600 text-white text-xs px-2 py-1 rounded-full';
                            badgeSpan.textContent = 'Best Solution';
                            header.appendChild(badgeSpan);
                        } else if (!isSuccess) {
                            const badgeSpan = document.createElement('span');
                            badgeSpan.className = 'bg-red-600 text-white text-xs px-2 py-1 rounded-full';
                            badgeSpan.textContent = 'Failed';
                            header.appendChild(badgeSpan);
                        }

                        implementationDiv.appendChild(header);

                        const content = document.createElement('div');
                        content.className = 'p-4 space-y-2';

                        // Performance metrics section
                        const metricsSection = document.createElement('div');
                        metricsSection.className = 'bg-blue-50 p-3 rounded text-sm mb-3';

                        const metricsLabel = document.createElement('h4');
                        metricsLabel.className = 'font-medium text-sm mb-1';
                        metricsLabel.textContent = 'Performance Metrics:';
                        metricsSection.appendChild(metricsLabel);

                        const metricsGrid = document.createElement('div');
                        metricsGrid.className = 'grid grid-cols-2 gap-x-2 gap-y-1 text-xs';

                        // Add metrics in grid format
                        // Function to format time (ms for < 1s, s for >= 1s)
                        const formatTimeValue = (seconds) => {
                            if (seconds < 1) {
                                return Math.round(seconds * 1000) + 'ms';
                            } else {
                                return seconds.toFixed(2) + 's';
                            }
                        };

                        const metrics = [
                            {label: 'Sandbox Creation:', value: formatTimeValue(result.sandbox_creation_time || 0)},
                            {label: 'Code Generation (GROQ):', value: formatTimeValue(result.groq_time || 0)},
                            {label: 'Total Generation Time:', value: formatTimeValue(result.code_generation_time || 0)},
                            {label: 'Total Sandbox Time:', value: formatTimeValue(result.total_sandbox_time || 0)}
                        ];

                        metrics.forEach(metric => {
                            const labelDiv = document.createElement('div');
                            labelDiv.className = 'text-gray-600';
                            labelDiv.textContent = metric.label;

                            const valueDiv = document.createElement('div');
                            valueDiv.textContent = metric.value;

                            metricsGrid.appendChild(labelDiv);
                            metricsGrid.appendChild(valueDiv);
                        });

                        metricsSection.appendChild(metricsGrid);
                        content.appendChild(metricsSection);

                        // Error message if there is one
                        if (result.error) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'bg-red-50 p-3 rounded text-sm text-red-700';
                            errorDiv.textContent = `Error: ${result.error}`;
                            content.appendChild(errorDiv);
                        }

                        // Code section
                        const codeSection = document.createElement('div');
                        codeSection.className = 'space-y-1';

                        const codeLabel = document.createElement('h4');
                        codeLabel.className = 'font-medium text-sm';
                        codeLabel.textContent = 'Generated Code:';
                        codeSection.appendChild(codeLabel);

                        // Strip markdown code blocks for display
                        let cleanCode = result.generated_code || 'No code available';
                        if (cleanCode.startsWith('```python') || cleanCode.startsWith('```')) {
                            // Find the end of the opening code block
                            const startIdx = cleanCode.indexOf('\n') + 1;
                            // Find the closing code block
                            const endIdx = cleanCode.lastIndexOf('```');
                            if (endIdx > startIdx) {
                                cleanCode = cleanCode.substring(startIdx, endIdx).trim();
                            } else {
                                cleanCode = cleanCode.replace(/```python/g, '').replace(/```/g, '').trim();
                            }
                        }

                        const codeContent = document.createElement('pre');
                        codeContent.className = 'bg-gray-50 p-3 rounded text-sm overflow-x-auto';
                        codeContent.textContent = cleanCode;
                        codeSection.appendChild(codeContent);

                        content.appendChild(codeSection);

                        // Output section
                        const outputSection = document.createElement('div');
                        outputSection.className = 'space-y-1';

                        const outputLabel = document.createElement('h4');
                        outputLabel.className = 'font-medium text-sm';
                        outputLabel.textContent = 'Execution Output:';
                        outputSection.appendChild(outputLabel);

                        const outputContent = document.createElement('pre');
                        outputContent.className = 'bg-gray-50 p-3 rounded text-sm overflow-x-auto';
                        outputContent.textContent = result.execution_output || 'No output available';
                        outputSection.appendChild(outputContent);

                        // Add execution status with more visual indication
                        const statusDiv = document.createElement('div');
                        if (result.execution_result === 'Success') {
                            statusDiv.className = 'mt-2 text-sm px-3 py-1 bg-green-100 text-green-800 rounded-md inline-block';
                            statusDiv.innerHTML = '✓ <strong>Success</strong>';
                        } else {
                            statusDiv.className = 'mt-2 text-sm px-3 py-1 bg-red-100 text-red-800 rounded-md inline-block';
                            statusDiv.innerHTML = '✗ <strong>Failed</strong>: ' + (result.error || result.execution_result);
                        }
                        outputSection.appendChild(statusDiv);

                        content.appendChild(outputSection);
                        implementationDiv.appendChild(content);

                        implementationsContainer.appendChild(implementationDiv);
                    });
                } else {
                    // No results
                    const noResults = document.createElement('div');
                    noResults.className = 'p-4 bg-gray-50 rounded-md text-center text-gray-500';
                    noResults.textContent = 'No implementation results were returned.';
                    implementationsContainer.appendChild(noResults);
                }

                // Show results
                loadingIndicator.classList.add('hidden');
                resultsContainer.classList.remove('hidden');
                
                // Fix node colors after results are shown
                setTimeout(fixNodeColors, 500);
                // And again after a longer delay to catch any overrides
                setTimeout(fixNodeColors, 2000);

            } catch (error) {
                console.error('Error:', error);
                errorMessage.textContent = error.message;
                errorContainer.classList.remove('hidden');
                loadingIndicator.classList.add('hidden');
                
                // Show connection help if it's a connection error
                const connectionErrorHelp = document.getElementById('connectionErrorHelp');
                if (error.message.includes("Connection failed") || 
                    error.message.includes("Failed to fetch") || 
                    error.message.includes("NetworkError")) {
                    connectionErrorHelp.classList.remove('hidden');
                } else {
                    connectionErrorHelp.classList.add('hidden');
                }
            } finally {
                // Re-enable submit button
                submitButton.disabled = false;
                submitButton.classList.remove('opacity-50');
            }
        });

        // Check if we're in test mode by looking at the form action
        document.addEventListener('DOMContentLoaded', function() {
            const formAction = document.getElementById('codeForm').getAttribute('action');
            if (formAction === '/test') {
                document.getElementById('testModeBanner').classList.remove('hidden');
            }

            // Pre-initialize visualization on page load with default sandbox count
            const defaultSandboxCount = parseInt(document.getElementById('sandbox_count').value) || 3;
            console.log("Pre-initializing visualization with", defaultSandboxCount, "sandboxes");
            initVisualization(defaultSandboxCount);
        });
    </script>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-8 mt-12">
        <div class="container mx-auto px-4">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-4 md:mb-0">
                    <p class="text-sm text-gray-400">Powered by Daytona AI Sandboxes</p>
                </div>
                <div class="flex space-x-6">
                    <a href="https://github.com/daytonaio" class="text-gray-300 hover:text-white" target="_blank">GitHub</a>
                    <a href="https://www.daytona.io/" class="text-gray-300 hover:text-white" target="_blank">Daytona.io</a>
                    <a href="https://daytona.io/docs" class="text-gray-300 hover:text-white" target="_blank">Documentation</a>
                </div>
            </div>

            <!-- Waitlist CTA -->
            <div class="mt-8 bg-indigo-700 rounded-lg p-6 text-center">
                <h3 class="text-xl font-bold mb-2">Ready to run AI code in Daytona?</h3>
                <p class="mb-4">Join the waitlist to get early access to Daytona's API key and sandbox capabilities</p>
                <a href="https://www.daytona.io/waitlist" target="_blank" class="inline-block bg-white text-indigo-700 font-bold py-2 px-6 rounded-md hover:bg-gray-100 transition">
                    Join the Waitlist
                </a>
            </div>
        </div>
    </footer>
</body>
</html>